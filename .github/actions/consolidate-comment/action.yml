name: Consolidate Review Comment
description: Consolidates all review results into a single PR comment with dropdowns

inputs:
  review_results:
    description: 'JSON string containing all review results'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true

outputs:
  comment_id:
    description: 'ID of the created or updated comment'
    value: ${{ steps.comment.outputs.comment_id }}
  comment_url:
    description: 'URL of the comment'
    value: ${{ steps.comment.outputs.comment_url }}

runs:
  using: composite
  steps:
    - name: Find and update or create comment
      id: comment
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        REVIEW_RESULTS: ${{ inputs.review_results }}
      run: |
        # Constants
        COMMENT_MARKER="<!-- ci-review-comment -->"

        # Parse review results
        echo "$REVIEW_RESULTS" > /tmp/review_results.json

        # Extract individual review data (4 reviews now)
        REQUIREMENTS=$(echo "$REVIEW_RESULTS" | jq -r '.requirements // {}')
        UI=$(echo "$REVIEW_RESULTS" | jq -r '.ui // {}')
        CODE_QUALITY=$(echo "$REVIEW_RESULTS" | jq -r '.code_quality // {}')
        CONTEXT=$(echo "$REVIEW_RESULTS" | jq -r '.context // {}')

        # Get commit SHA
        COMMIT_SHA="${{ github.sha }}"
        SHORT_SHA="${COMMIT_SHA:0:7}"

        # Count passed/total reviews
        TOTAL=0
        PASSED=0

        count_review() {
          local review="$1"
          local status=$(echo "$review" | jq -r '.status // "skipped"')
          if [ "$status" != "skipped" ]; then
            TOTAL=$((TOTAL + 1))
            if [ "$status" = "passed" ]; then
              PASSED=$((PASSED + 1))
            fi
          fi
        }

        count_review "$REQUIREMENTS"
        count_review "$UI"
        count_review "$CODE_QUALITY"
        count_review "$CONTEXT"

        # Helper: generate status badge
        get_status_badge() {
          local status="$1"
          case "$status" in
            "passed") echo "PASSED" ;;
            "failed") echo "FAILED" ;;
            "skipped") echo "Skipped" ;;
            *) echo "Unknown" ;;
          esac
        }

        # Build Requirements section
        build_requirements_section() {
          local status=$(echo "$REQUIREMENTS" | jq -r '.status // "skipped"')
          local confidence=$(echo "$REQUIREMENTS" | jq -r '.confidence // 0')
          local summary=$(echo "$REQUIREMENTS" | jq -r '.summary // ""')

          if [ "$status" = "skipped" ]; then
            cat <<EOF
        <details>
        <summary>Requirements Review -- Skipped</summary>

        No linked issue found or no requirements to verify.

        </details>
        EOF
          else
            local badge=$(get_status_badge "$status")
            local met=$(echo "$REQUIREMENTS" | jq -r '.requirements_met // []')
            local missing=$(echo "$REQUIREMENTS" | jq -r '.requirements_missing // []')

            local content=""
            if [ "$met" != "[]" ] && [ "$met" != "null" ]; then
              content="${content}

        ### Requirements Met"
              while IFS= read -r req; do
                [ -n "$req" ] && [ "$req" != "null" ] && content="${content}
        - $req"
              done < <(echo "$met" | jq -r '.[]' 2>/dev/null)
            fi

            if [ "$missing" != "[]" ] && [ "$missing" != "null" ]; then
              content="${content}

        ### Requirements Missing"
              while IFS= read -r req; do
                [ -n "$req" ] && [ "$req" != "null" ] && content="${content}
        - $req"
              done < <(echo "$missing" | jq -r '.[]' 2>/dev/null)
            fi

            cat <<EOF
        <details>
        <summary>Requirements Review $badge | Confidence: $confidence</summary>

        ### Summary
        $summary
        $content

        </details>
        EOF
          fi
        }

        # Build UI section
        build_ui_section() {
          local status=$(echo "$UI" | jq -r '.status // "skipped"')
          local confidence=$(echo "$UI" | jq -r '.confidence // 0')
          local summary=$(echo "$UI" | jq -r '.summary // ""')

          if [ "$status" = "skipped" ]; then
            cat <<EOF
        <details>
        <summary>UI Review -- Skipped</summary>

        No UI files changed or no screenshots available.

        </details>
        EOF
          else
            local badge=$(get_status_badge "$status")
            local bp=$(echo "$UI" | jq -r '.best_practices_evaluation // {}')
            local critical=$(echo "$UI" | jq -r '.total_critical // 0')
            local major=$(echo "$UI" | jq -r '.total_major // 0')
            local minor=$(echo "$UI" | jq -r '.total_minor // 0')

            local content="
        ### Issue Summary
        | Level | Count |
        |-------|-------|
        | Critical | $critical |
        | Major | $major |
        | Minor | $minor |"

            if [ "$bp" != "{}" ] && [ "$bp" != "null" ]; then
              local visual=$(echo "$bp" | jq -r '.visual_design // "N/A"')
              local layout=$(echo "$bp" | jq -r '.layout_responsiveness // "N/A"')
              local a11y=$(echo "$bp" | jq -r '.accessibility // "N/A"')
              local ux=$(echo "$bp" | jq -r '.user_experience // "N/A"')
              local elegance=$(echo "$bp" | jq -r '.modern_elegance // "N/A"')

              content="${content}

        ### Best Practices Scores
        | Category | Score |
        |----------|-------|
        | Visual Design | ${visual}/10 |
        | Layout | ${layout}/10 |
        | Accessibility | ${a11y}/10 |
        | UX | ${ux}/10 |
        | Elegance | ${elegance}/10 |"
            fi

            cat <<EOF
        <details>
        <summary>UI Review $badge | Confidence: $confidence</summary>

        ### Summary
        $summary
        $content

        </details>
        EOF
          fi
        }

        # Build Code Quality section
        build_code_quality_section() {
          local status=$(echo "$CODE_QUALITY" | jq -r '.status // "skipped"')
          local confidence=$(echo "$CODE_QUALITY" | jq -r '.confidence // 0')
          local summary=$(echo "$CODE_QUALITY" | jq -r '.summary // ""')

          if [ "$status" = "skipped" ]; then
            cat <<EOF
        <details>
        <summary>Code Quality Review -- Skipped</summary>

        No code files changed.

        </details>
        EOF
          else
            local badge=$(get_status_badge "$status")
            local scores=$(echo "$CODE_QUALITY" | jq -r '.principle_scores // {}')

            local content=""
            if [ "$scores" != "{}" ] && [ "$scores" != "null" ]; then
              local dry=$(echo "$scores" | jq -r '.dry // "N/A"')
              local yagni=$(echo "$scores" | jq -r '.yagni // "N/A"')
              local modularity=$(echo "$scores" | jq -r '.modularity // "N/A"')
              local complexity=$(echo "$scores" | jq -r '.complexity // "N/A"')
              local coupling=$(echo "$scores" | jq -r '.coupling // "N/A"')
              local cohesion=$(echo "$scores" | jq -r '.cohesion // "N/A"')

              content="
        ### Principle Scores
        | Principle | Score |
        |-----------|-------|
        | DRY | ${dry}/10 |
        | YAGNI | ${yagni}/10 |
        | Modularity | ${modularity}/10 |
        | Complexity | ${complexity}/10 |
        | Coupling | ${coupling}/10 |
        | Cohesion | ${cohesion}/10 |"
            fi

            local blocking=$(echo "$CODE_QUALITY" | jq -r '.blocking_issues // []')
            if [ "$blocking" != "[]" ] && [ "$blocking" != "null" ]; then
              content="${content}

        ### Blocking Issues"
              while IFS= read -r issue; do
                [ -n "$issue" ] && [ "$issue" != "null" ] && content="${content}
        - $issue"
              done < <(echo "$blocking" | jq -r '.[]' 2>/dev/null)
            fi

            cat <<EOF
        <details>
        <summary>Code Quality Review $badge | Confidence: $confidence</summary>

        ### Summary
        $summary
        $content

        </details>
        EOF
          fi
        }

        # Build Context section (with sub-reviews)
        build_context_section() {
          local status=$(echo "$CONTEXT" | jq -r '.status // "skipped"')
          local summary=$(echo "$CONTEXT" | jq -r '.summary // ""')

          if [ "$status" = "skipped" ]; then
            cat <<EOF
        <details>
        <summary>Context Review -- Skipped</summary>

        No context files to review.

        </details>
        EOF
          else
            local badge=$(get_status_badge "$status")

            # Extract sub-reviews
            local rules_status=$(echo "$CONTEXT" | jq -r '.sub_reviews.rules.status // "skipped"')
            local memory_status=$(echo "$CONTEXT" | jq -r '.sub_reviews.project_memory.status // "skipped"')
            local agents_status=$(echo "$CONTEXT" | jq -r '.sub_reviews.agents.status // "skipped"')
            local skills_status=$(echo "$CONTEXT" | jq -r '.sub_reviews.skills.status // "skipped"')

            local rules_summary=$(echo "$CONTEXT" | jq -r '.sub_reviews.rules.summary // "N/A"')
            local memory_summary=$(echo "$CONTEXT" | jq -r '.sub_reviews.project_memory.summary // "N/A"')
            local agents_summary=$(echo "$CONTEXT" | jq -r '.sub_reviews.agents.summary // "N/A"')
            local skills_summary=$(echo "$CONTEXT" | jq -r '.sub_reviews.skills.summary // "N/A"')

            cat <<EOF
        <details>
        <summary>Context Review $badge</summary>

        ### Summary
        $summary

        #### Sub-Reviews

        | Review | Status | Summary |
        |--------|--------|---------|
        | Rules | $(get_status_badge "$rules_status") | $rules_summary |
        | Project Memory | $(get_status_badge "$memory_status") | $memory_summary |
        | Agents | $(get_status_badge "$agents_status") | $agents_summary |
        | Skills | $(get_status_badge "$skills_status") | $skills_summary |

        </details>
        EOF
          fi
        }

        # Build the complete comment
        REQUIREMENTS_SECTION=$(build_requirements_section)
        UI_SECTION=$(build_ui_section)
        CODE_QUALITY_SECTION=$(build_code_quality_section)
        CONTEXT_SECTION=$(build_context_section)

        COMMENT_BODY="$COMMENT_MARKER
        ## Code Review Results

        **Commit:** \`$SHORT_SHA\` | **Status:** $PASSED/$TOTAL Passed

        ---

        $REQUIREMENTS_SECTION

        $UI_SECTION

        $CODE_QUALITY_SECTION

        $CONTEXT_SECTION

        ---

        *Automated by Claude Code CI*"

        # Save comment body
        echo "$COMMENT_BODY" > /tmp/comment_body.md

        # Get PR number
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          PR_NUMBER="${{ github.event.pull_request.number }}"
        else
          PR_NUMBER=$(gh pr list --state open --json number,headRefName --jq ".[] | select(.headRefName == \"${{ github.ref_name }}\") | .number" 2>/dev/null || echo "")
        fi

        if [ -z "$PR_NUMBER" ]; then
          echo "No PR found, skipping comment"
          echo "comment_id=" >> $GITHUB_OUTPUT
          echo "comment_url=" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Find existing comment
        EXISTING_COMMENT_ID=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
          --jq ".[] | select(.body | contains(\"$COMMENT_MARKER\")) | .id" \
          2>/dev/null | head -1)

        if [ -n "$EXISTING_COMMENT_ID" ]; then
          RESPONSE=$(gh api \
            --method PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/issues/comments/${EXISTING_COMMENT_ID}" \
            -f body="$(cat /tmp/comment_body.md)")
          COMMENT_ID="$EXISTING_COMMENT_ID"
          echo "Updated existing comment: $COMMENT_ID"
        else
          RESPONSE=$(gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            -f body="$(cat /tmp/comment_body.md)")
          COMMENT_ID=$(echo "$RESPONSE" | jq -r '.id')
          echo "Created new comment: $COMMENT_ID"
        fi

        COMMENT_URL=$(echo "$RESPONSE" | jq -r '.html_url')
        echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT
        echo "comment_url=$COMMENT_URL" >> $GITHUB_OUTPUT
