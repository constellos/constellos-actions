name: Code Quality Review
description: Reviews code for DRY, YAGNI, modularity, and other quality principles

inputs:
  github_token:
    description: 'GitHub token for API access'
    required: true
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true

outputs:
  passed:
    description: 'Whether the review passed'
    value: ${{ steps.result.outputs.passed }}
  result_json:
    description: 'Full JSON result'
    value: ${{ steps.result.outputs.result_json }}

runs:
  using: composite
  steps:
    - name: Get changed files and imports
      id: context
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Get changed files
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' > /tmp/changed_files.txt
        else
          git diff --name-only HEAD~1 HEAD > /tmp/changed_files.txt 2>/dev/null || echo "" > /tmp/changed_files.txt
        fi

        # Filter to code files only
        grep -E '\.(ts|tsx|js|jsx|py|go|rs|java|rb)$' /tmp/changed_files.txt > /tmp/changed_code_files.txt 2>/dev/null || echo "" > /tmp/changed_code_files.txt

        CHANGED_COUNT=$(wc -l < /tmp/changed_code_files.txt | tr -d ' ')
        echo "changed_count=$CHANGED_COUNT" >> $GITHUB_OUTPUT

        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "No code files changed"
          exit 0
        fi

        # Find imports/dependencies of changed files
        mkdir -p /tmp/related_files
        while IFS= read -r file; do
          if [ -f "$file" ]; then
            # Extract imports from TypeScript/JavaScript files
            if [[ "$file" =~ \.(ts|tsx|js|jsx)$ ]]; then
              grep -E "^import .* from ['\"]" "$file" 2>/dev/null | \
                sed "s/.*from ['\"]\\([^'\"]*\\)['\"].*/\\1/" | \
                while read -r import_path; do
                  # Handle relative imports
                  if [[ "$import_path" == .* ]]; then
                    dir=$(dirname "$file")
                    # Try common extensions
                    for ext in "" ".ts" ".tsx" ".js" ".jsx" "/index.ts" "/index.tsx" "/index.js"; do
                      resolved="$dir/$import_path$ext"
                      if [ -f "$resolved" ]; then
                        echo "$resolved" >> /tmp/related_files/imports.txt
                        break
                      fi
                    done
                  fi
                done
            fi
          fi
        done < /tmp/changed_code_files.txt

        # Deduplicate related files
        if [ -f /tmp/related_files/imports.txt ]; then
          sort -u /tmp/related_files/imports.txt > /tmp/related_imports.txt
          RELATED_COUNT=$(wc -l < /tmp/related_imports.txt | tr -d ' ')
        else
          echo "" > /tmp/related_imports.txt
          RELATED_COUNT=0
        fi
        echo "related_count=$RELATED_COUNT" >> $GITHUB_OUTPUT

        # Combine for analysis scope
        cat /tmp/changed_code_files.txt /tmp/related_imports.txt 2>/dev/null | sort -u > /tmp/analysis_scope.txt

    - name: Run Code Quality Review
      if: steps.context.outputs.changed_count != '0'
      id: review
      uses: anthropics/claude-code-base-action@beta
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        allowed_tools: "View,GlobTool,Grep,Bash(git diff:*),Bash(cat:*),Bash(find:*)"
        max_turns: 20
        prompt: |
          # Code Quality Review Agent

          You are a code quality review specialist. Your job is to evaluate code changes against software engineering best practices and principles.

          ## Context
          - Changed Files: ${{ steps.context.outputs.changed_count }}
          - Related Files (imports): ${{ steps.context.outputs.related_count }}

          ## Files to Analyze
          Read /tmp/analysis_scope.txt for the full list of files to review.
          Read /tmp/changed_code_files.txt for just the files that were directly changed.

          ## Your Task

          1. **Read the changed files**:
             - Use `git diff HEAD~1 HEAD -- <file>` to see what changed
             - Understand the nature of the changes

          2. **Read related files**:
             - Check /tmp/related_imports.txt for files imported by changed files
             - Understand how changes interact with existing code

          3. **Evaluate against quality principles**:

             **DRY (Don't Repeat Yourself)**:
             - Is there duplicated code that should be extracted?
             - Are there patterns that appear multiple times?
             - Could shared utilities reduce repetition?

             **YAGNI (You Ain't Gonna Need It)**:
             - Is there over-engineering or premature abstraction?
             - Are there unused parameters, options, or flexibility?
             - Is the solution more complex than needed?

             **Modularity**:
             - Are files/functions focused on a single responsibility?
             - Are dependencies well-organized?
             - Could large files be split?

             **Complexity**:
             - Are there deeply nested conditionals?
             - Are functions too long (>50 lines)?
             - Is the logic easy to follow?

             **Coupling**:
             - Are modules tightly coupled?
             - Would changes here require changes elsewhere?
             - Are interfaces clean and minimal?

             **Cohesion**:
             - Do related things stay together?
             - Are unrelated concerns separated?
             - Is the code organization logical?

          4. **Identify issues by severity**:
             - **Critical**: Major violations that will cause maintenance problems
             - **Major**: Significant issues that should be addressed
             - **Minor**: Style/preference issues, nice-to-haves

          5. **Make your decision**:
             - PASS: No critical issues, code follows reasonable practices
             - FAIL: Critical quality issues that should be fixed before merge

          ## IMPORTANT RULES

          - **DO NOT edit any files** - you are a reviewer only
          - Focus on the CHANGES, not pre-existing code quality issues
          - Be pragmatic - perfect is the enemy of good
          - Consider the context and scope of the changes
          - Avoid nitpicking on style if it's consistent

          ## Output Format

          Your response MUST end with a JSON code block in this exact format:

          ```json
          {
            "passed": true/false,
            "confidence": 0.0-1.0,
            "file_analyses": [
              {
                "file_path": "path/to/file.ts",
                "imports_analyzed": ["list of related files checked"],
                "issues": [
                  {
                    "type": "DRY|YAGNI|MODULARITY|COMPLEXITY|COUPLING|COHESION",
                    "severity": "critical|major|minor",
                    "line_range": "10-25",
                    "description": "what the issue is",
                    "suggestion": "how to fix it"
                  }
                ],
                "positive_aspects": ["good things about this code"]
              }
            ],
            "principle_scores": {
              "dry": 1-10,
              "yagni": 1-10,
              "modularity": 1-10,
              "complexity": 1-10,
              "coupling": 1-10,
              "cohesion": 1-10
            },
            "blocking_issues": ["critical issues that block merge"],
            "refactoring_suggestions": [
              {
                "priority": "high|medium|low",
                "description": "what to refactor",
                "affected_files": ["files involved"]
              }
            ],
            "summary": "Brief summary of code quality assessment"
          }
          ```

    - name: Extract result
      id: result
      shell: bash
      run: |
        # Check if review was skipped (no code files)
        if [ "${{ steps.context.outputs.changed_count }}" = "0" ]; then
          echo '{"passed":true,"status":"skipped","summary":"No code files changed"}' > /tmp/review_output.json
          echo "passed=true" >> $GITHUB_OUTPUT
          echo "result_json=$(cat /tmp/review_output.json | jq -c '.')" >> $GITHUB_OUTPUT
          exit 0
        fi

        EXEC_FILE="${{ steps.review.outputs.execution_file }}"
        CONCLUSION="${{ steps.review.outputs.conclusion }}"

        if [ "$CONCLUSION" = "success" ]; then
          DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Code quality review completed","status":"passed"}'
        else
          DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Code quality review found issues","status":"failed"}'
        fi

        if [ -f "$EXEC_FILE" ]; then
          LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
          OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')

          if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
            PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
            if [ "$PASSED" = "true" ]; then
              OUTPUT=$(echo "$OUTPUT" | jq '. + {status: "passed"}')
            else
              OUTPUT=$(echo "$OUTPUT" | jq '. + {status: "failed"}')
            fi
            echo "$OUTPUT" > /tmp/review_output.json
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi
        else
          echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
        fi

        PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
        echo "passed=$PASSED" >> $GITHUB_OUTPUT

        RESULT_JSON=$(cat /tmp/review_output.json | jq -c '.')
        echo "result_json=$RESULT_JSON" >> $GITHUB_OUTPUT
